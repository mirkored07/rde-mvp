(function(){
  const STYLE_ID = "plotly-stub-style";
  if (typeof document !== "undefined" && !document.getElementById(STYLE_ID)) {
    const style = document.createElement("style");
    style.id = STYLE_ID;
    style.textContent = `
      .plotly-stub {
        position: relative;
        width: 100%;
        height: 100%;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        color: #1f2937;
      }
      .plotly-stub svg {
        width: 100%;
        height: 100%;
        display: block;
      }
      .plotly-stub-legend {
        position: absolute;
        left: 12px;
        top: 12px;
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        font-size: 11px;
        background: rgba(15,23,42,0.7);
        color: #f8fafc;
        padding: 6px 8px;
        border-radius: 6px;
      }
      .plotly-stub-legend span {
        display: inline-flex;
        align-items: center;
        gap: 4px;
      }
      .plotly-stub-legend i {
        display: inline-block;
        width: 10px;
        height: 10px;
        border-radius: 9999px;
      }
      .plotly-stub-axis-label {
        position: absolute;
        font-size: 11px;
        color: inherit;
      }
      .plotly-stub-axis-label--left {
        left: 4px;
        top: 50%;
        transform: translateY(-50%) rotate(-90deg);
        transform-origin: left top;
      }
      .plotly-stub-axis-label--right {
        right: 4px;
        top: 50%;
        transform: translateY(-50%) rotate(90deg);
        transform-origin: right top;
      }
      .plotly-stub-axis-label--bottom {
        bottom: 4px;
        left: 50%;
        transform: translateX(-50%);
      }
    `;
    document.head.appendChild(style);
  }

  function numeric(value, fallback) {
    if (value === null || value === undefined || value === "") {
      return fallback;
    }
    if (typeof value === "number" && Number.isFinite(value)) {
      return value;
    }
    if (value instanceof Date) {
      const time = value.getTime();
      return Number.isFinite(time) ? time : fallback;
    }
    const parsed = Date.parse(value);
    if (!Number.isNaN(parsed)) {
      return parsed;
    }
    const num = Number(value);
    return Number.isFinite(num) ? num : fallback;
  }

  function ensureArray(value, length) {
    if (Array.isArray(value)) {
      return value;
    }
    if (length && Number.isInteger(length)) {
      return Array.from({ length }, (_, index) => index);
    }
    return [];
  }

  function axisRange(values) {
    const filtered = values.filter((value) => Number.isFinite(value));
    if (!filtered.length) {
      return { min: 0, max: 1 };
    }
    let min = Math.min(...filtered);
    let max = Math.max(...filtered);
    if (min === max) {
      if (min === 0) {
        max = 1;
      } else {
        const delta = Math.abs(min) * 0.1;
        min -= delta;
        max += delta;
      }
    }
    return { min, max };
  }

  function createSvg(width, height) {
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
    svg.setAttribute("preserveAspectRatio", "none");
    svg.setAttribute("role", "img");
    svg.setAttribute("aria-hidden", "true");
    return svg;
  }

  function createPath(points, color, width) {
    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
    path.setAttribute("fill", "none");
    path.setAttribute("stroke", color || "#2563eb");
    path.setAttribute("stroke-width", width || 2);
    const d = points
      .map((point, index) => `${index === 0 ? "M" : "L"}${point.x.toFixed(2)},${point.y.toFixed(2)}`)
      .join(" ");
    path.setAttribute("d", d);
    path.setAttribute("stroke-linejoin", "round");
    path.setAttribute("stroke-linecap", "round");
    return path;
  }

  function buildLegend(traces) {
    const legend = document.createElement("div");
    legend.className = "plotly-stub-legend";
    traces.forEach((trace) => {
      const label = document.createElement("span");
      const swatch = document.createElement("i");
      swatch.style.background = (trace.line && trace.line.color) || "#2563eb";
      label.appendChild(swatch);
      label.appendChild(document.createTextNode(trace.name || "Series"));
      legend.appendChild(label);
    });
    return legend;
  }

  function axisLabel(text, position) {
    if (!text) {
      return null;
    }
    const label = document.createElement("div");
    label.className = `plotly-stub-axis-label plotly-stub-axis-label--${position}`;
    label.textContent = text;
    return label;
  }

  function preparePoints(trace, xNumbers) {
    const yValues = ensureArray(trace.y, xNumbers.length).map((value) =>
      Number.isFinite(Number(value)) ? Number(value) : null,
    );
    const points = [];
    for (let index = 0; index < xNumbers.length; index += 1) {
      const yValue = yValues[index];
      const xValue = xNumbers[index];
      if (!Number.isFinite(yValue) || !Number.isFinite(xValue)) {
        continue;
      }
      points.push({ x: xValue, y: yValue });
    }
    return points;
  }

  function getAxisKey(trace) {
    if (trace && typeof trace.yaxis === "string" && trace.yaxis.toLowerCase() === "y2") {
      return "y2";
    }
    return "y";
  }

  function expandRange(range, padding) {
    const delta = (range.max - range.min) * (padding ?? 0.05);
    return {
      min: range.min - delta,
      max: range.max + delta,
    };
  }

  function projectPoint(point, xRange, yRange, plotBox) {
    const xRatio = (point.x - xRange.min) / (xRange.max - xRange.min || 1);
    const yRatio = (point.y - yRange.min) / (yRange.max - yRange.min || 1);
    const x = plotBox.left + xRatio * plotBox.width;
    const y = plotBox.top + (1 - yRatio) * plotBox.height;
    return { x, y };
  }

  function render(container, traces, layout) {
    if (!container) {
      return;
    }

    const width = container.clientWidth || 640;
    const height = container.clientHeight || 360;
    const padding = { top: 24, right: 60, bottom: 40, left: 60 };
    const plotBox = {
      top: padding.top,
      left: padding.left,
      width: Math.max(width - padding.left - padding.right, 100),
      height: Math.max(height - padding.top - padding.bottom, 100),
    };

    container.innerHTML = "";
    const wrapper = document.createElement("div");
    wrapper.className = "plotly-stub";
    wrapper.style.setProperty("color", (layout && layout.font && layout.font.color) || "#1f2937");
    wrapper.style.setProperty("background", "transparent");

    const svg = createSvg(width, height);

    const allX = [];
    const tracePoints = traces.map((trace) => {
      const xSource = ensureArray(trace.x, ensureArray(trace.y).length);
      const xNumbers = xSource.map((value, index) => numeric(value, index));
      allX.push(...xNumbers);
      const points = preparePoints(trace, xNumbers);
      return { trace, points };
    });

    const xRange = expandRange(axisRange(allX), 0.02);
    const axisValues = { y: [], y2: [] };
    tracePoints.forEach(({ trace, points }) => {
      const key = getAxisKey(trace);
      points.forEach((point) => {
        axisValues[key].push(point.y);
      });
    });
    const yRanges = {
      y: expandRange(axisRange(axisValues.y), 0.05),
      y2: expandRange(axisRange(axisValues.y2), 0.05),
    };

    const axesGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
    axesGroup.setAttribute("stroke", (layout && layout.xaxis && layout.xaxis.color) || wrapper.style.color);
    axesGroup.setAttribute("stroke-width", "1");
    axesGroup.setAttribute("fill", "none");

    // X axis
    const xAxis = document.createElementNS("http://www.w3.org/2000/svg", "line");
    xAxis.setAttribute("x1", plotBox.left);
    xAxis.setAttribute("x2", plotBox.left + plotBox.width);
    xAxis.setAttribute("y1", plotBox.top + plotBox.height);
    xAxis.setAttribute("y2", plotBox.top + plotBox.height);
    axesGroup.appendChild(xAxis);

    // Left axis
    const yAxis = document.createElementNS("http://www.w3.org/2000/svg", "line");
    yAxis.setAttribute("x1", plotBox.left);
    yAxis.setAttribute("x2", plotBox.left);
    yAxis.setAttribute("y1", plotBox.top);
    yAxis.setAttribute("y2", plotBox.top + plotBox.height);
    axesGroup.appendChild(yAxis);

    // Right axis (if we have y2 data)
    if (axisValues.y2.length) {
      const yAxis2 = document.createElementNS("http://www.w3.org/2000/svg", "line");
      yAxis2.setAttribute("x1", plotBox.left + plotBox.width);
      yAxis2.setAttribute("x2", plotBox.left + plotBox.width);
      yAxis2.setAttribute("y1", plotBox.top);
      yAxis2.setAttribute("y2", plotBox.top + plotBox.height);
      axesGroup.appendChild(yAxis2);
    }

    svg.appendChild(axesGroup);

    const pathsGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
    tracePoints.forEach(({ trace, points }) => {
      if (!points.length) {
        return;
      }
      const axisKey = getAxisKey(trace);
      const yRange = yRanges[axisKey];
      const projected = points.map((point) => projectPoint(point, xRange, yRange, plotBox));
      const path = createPath(projected, trace.line && trace.line.color, (trace.line && trace.line.width) || 2);
      pathsGroup.appendChild(path);
    });
    svg.appendChild(pathsGroup);

    wrapper.appendChild(svg);

    if (traces.length) {
      wrapper.appendChild(buildLegend(traces));
    }

    const leftLabel = axisLabel((layout && layout.yaxis && layout.yaxis.title) || "");
    if (leftLabel) {
      leftLabel.classList.add("plotly-stub-axis-label--left");
      wrapper.appendChild(leftLabel);
    }

    if (axisValues.y2.length) {
      const rightLabel = axisLabel((layout && layout.yaxis2 && layout.yaxis2.title) || "");
      if (rightLabel) {
        rightLabel.classList.add("plotly-stub-axis-label--right");
        wrapper.appendChild(rightLabel);
      }
    }

    const bottomLabel = axisLabel((layout && layout.xaxis && layout.xaxis.title) || "");
    if (bottomLabel) {
      bottomLabel.classList.add("plotly-stub-axis-label--bottom");
      wrapper.appendChild(bottomLabel);
    }

    container.appendChild(wrapper);
  }

  function applyUpdates(target, updates) {
    if (!updates || typeof updates !== "object") {
      return;
    }
    Object.entries(updates).forEach(([key, value]) => {
      if (key.includes(".")) {
        const parts = key.split(".");
        let cursor = target;
        for (let index = 0; index < parts.length - 1; index += 1) {
          const part = parts[index];
          if (!cursor[part] || typeof cursor[part] !== "object") {
            cursor[part] = {};
          }
          cursor = cursor[part];
        }
        cursor[parts[parts.length - 1]] = value;
      } else {
        target[key] = value;
      }
    });
  }

  const PlotlyStub = {
    newPlot(container, traces, layout, config) {
      const element = typeof container === "string" ? document.getElementById(container) : container;
      if (!element) {
        return Promise.resolve();
      }
      const safeTraces = Array.isArray(traces) ? traces.filter(Boolean) : [];
      const safeLayout = layout && typeof layout === "object" ? { ...layout } : {};
      element.__plotlyState = { traces: safeTraces, layout: safeLayout, config: config || {} };
      render(element, safeTraces, safeLayout);
      return Promise.resolve();
    },
    purge(container) {
      const element = typeof container === "string" ? document.getElementById(container) : container;
      if (!element) {
        return;
      }
      element.innerHTML = "";
      delete element.__plotlyState;
    },
    relayout(container, updates) {
      const element = typeof container === "string" ? document.getElementById(container) : container;
      if (!element || !element.__plotlyState) {
        return Promise.resolve();
      }
      applyUpdates(element.__plotlyState.layout, updates);
      render(element, element.__plotlyState.traces, element.__plotlyState.layout);
      return Promise.resolve();
    },
    Plots: {
      resize(container) {
        const element = typeof container === "string" ? document.getElementById(container) : container;
        if (!element || !element.__plotlyState) {
          return;
        }
        render(element, element.__plotlyState.traces, element.__plotlyState.layout);
      },
    },
  };

  if (typeof window !== "undefined") {
    window.Plotly = PlotlyStub;
  }
})();
